
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>vaultenv-cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/vaultenv/vaultenv-cli/cmd/vaultenv-cli/main.go (0.0%)</option>
				
				<option value="file1">github.com/vaultenv/vaultenv-cli/internal/cmd/completion.go (4.9%)</option>
				
				<option value="file2">github.com/vaultenv/vaultenv-cli/internal/cmd/execute.go (55.2%)</option>
				
				<option value="file3">github.com/vaultenv/vaultenv-cli/internal/cmd/get.go (94.3%)</option>
				
				<option value="file4">github.com/vaultenv/vaultenv-cli/internal/cmd/init.go (10.6%)</option>
				
				<option value="file5">github.com/vaultenv/vaultenv-cli/internal/cmd/list.go (91.2%)</option>
				
				<option value="file6">github.com/vaultenv/vaultenv-cli/internal/cmd/set.go (75.4%)</option>
				
				<option value="file7">github.com/vaultenv/vaultenv-cli/internal/cmd/version.go (25.0%)</option>
				
				<option value="file8">github.com/vaultenv/vaultenv-cli/internal/test/helpers.go (45.1%)</option>
				
				<option value="file9">github.com/vaultenv/vaultenv-cli/internal/ui/errors.go (100.0%)</option>
				
				<option value="file10">github.com/vaultenv/vaultenv-cli/internal/ui/output.go (100.0%)</option>
				
				<option value="file11">github.com/vaultenv/vaultenv-cli/pkg/encryption/aes_gcm.go (85.1%)</option>
				
				<option value="file12">github.com/vaultenv/vaultenv-cli/pkg/encryption/chacha.go (0.0%)</option>
				
				<option value="file13">github.com/vaultenv/vaultenv-cli/pkg/encryption/interface.go (20.0%)</option>
				
				<option value="file14">github.com/vaultenv/vaultenv-cli/pkg/keystore/keystore.go (0.0%)</option>
				
				<option value="file15">github.com/vaultenv/vaultenv-cli/pkg/keystore/mock.go (86.2%)</option>
				
				<option value="file16">github.com/vaultenv/vaultenv-cli/pkg/storage/interface.go (0.0%)</option>
				
				<option value="file17">github.com/vaultenv/vaultenv-cli/pkg/storage/memory.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
    "fmt"
    "os"

    "github.com/vaultenv/vaultenv-cli/internal/cmd"
)

// These variables are populated by the build process
// This allows us to display accurate version information
var (
    version   = "dev"     // Will be set by goreleaser
    commit    = "unknown" // Git commit hash for debugging
    buildTime = "unknown" // Build timestamp
    builtBy   = "unknown" // Build system identifier
)

func main() <span class="cov0" title="0">{
    // Pass version information to our command handler
    // This separation makes testing easier
    buildInfo := cmd.BuildInfo{
        Version:   version,
        Commit:    commit,
        BuildTime: buildTime,
        BuiltBy:   builtBy,
    }

    // Execute our root command and handle any errors
    if err := cmd.Execute(buildInfo); err != nil </span><span class="cov0" title="0">{
        // Exit with non-zero code to indicate failure
        // This is important for CI/CD systems
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
    "fmt"
    "os"
    "strings"

    "github.com/spf13/cobra"
    "github.com/vaultenv/vaultenv-cli/pkg/storage"
)

func newCompletionCommand() *cobra.Command <span class="cov8" title="1">{
    cmd := &amp;cobra.Command{
        Use:   "completion [bash|zsh|fish|powershell]",
        Short: "Generate shell completion script",
        Long: `Generate shell completion script for vaultenv-cli.

To load completions in your current shell session:

  Bash:
    $ source &lt;(vaultenv-cli completion bash)

  Zsh:
    $ source &lt;(vaultenv-cli completion zsh)

  Fish:
    $ vaultenv-cli completion fish | source

  PowerShell:
    PS&gt; vaultenv-cli completion powershell | Out-String | Invoke-Expression

To load completions for every new session, execute once:

  Bash:
    $ vaultenv-cli completion bash &gt; /etc/bash_completion.d/vaultenv-cli

  Zsh:
    $ vaultenv-cli completion zsh &gt; "${fpath[1]}/_vaultenv-cli"

  Fish:
    $ vaultenv-cli completion fish &gt; ~/.config/fish/completions/vaultenv-cli.fish

  PowerShell:
    PS&gt; vaultenv-cli completion powershell &gt; $PROFILE`,

        DisableFlagsInUseLine: true,
        ValidArgs:             []string{"bash", "zsh", "fish", "powershell"},
        Args:                  cobra.ExactValidArgs(1),
        RunE:                  runCompletion,
    }

    return cmd
}</span>

func runCompletion(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
    switch args[0] </span>{
    case "bash":<span class="cov0" title="0">
        return cmd.Root().GenBashCompletion(os.Stdout)</span>
    case "zsh":<span class="cov0" title="0">
        return cmd.Root().GenZshCompletion(os.Stdout)</span>
    case "fish":<span class="cov0" title="0">
        return cmd.Root().GenFishCompletion(os.Stdout, true)</span>
    case "powershell":<span class="cov0" title="0">
        return cmd.Root().GenPowerShellCompletionWithDesc(os.Stdout)</span>
    default:<span class="cov0" title="0">
        return fmt.Errorf("unsupported shell: %s", args[0])</span>
    }
}

// environmentCompletion provides shell completion for environment names
func environmentCompletion(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
    // In a real implementation, this would fetch from config
    environments := []string{"development", "staging", "production", "testing"}

    var matches []string
    for _, env := range environments </span><span class="cov0" title="0">{
        if strings.HasPrefix(env, toComplete) </span><span class="cov0" title="0">{
            matches = append(matches, env)
        }</span>
    }

    <span class="cov0" title="0">return matches, cobra.ShellCompDirectiveNoFileComp</span>
}

// variableNameCompletion provides shell completion for variable names
func variableNameCompletion(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
    // Common environment variable patterns
    suggestions := []string{
        "DATABASE_URL",
        "API_KEY",
        "API_SECRET",
        "AWS_ACCESS_KEY_ID",
        "AWS_SECRET_ACCESS_KEY",
        "AWS_REGION",
        "REDIS_URL",
        "REDIS_PASSWORD",
        "JWT_SECRET",
        "JWT_EXPIRY",
        "SMTP_HOST",
        "SMTP_PORT",
        "SMTP_USER",
        "SMTP_PASSWORD",
        "PORT",
        "HOST",
        "NODE_ENV",
        "LOG_LEVEL",
        "DEBUG",
        "SENTRY_DSN",
        "STRIPE_API_KEY",
        "STRIPE_SECRET_KEY",
        "GITHUB_TOKEN",
        "GITLAB_TOKEN",
    }

    var matches []string
    for _, suggestion := range suggestions </span><span class="cov0" title="0">{
        if strings.HasPrefix(strings.ToUpper(suggestion), strings.ToUpper(toComplete)) </span><span class="cov0" title="0">{
            matches = append(matches, suggestion)
        }</span>
    }

    <span class="cov0" title="0">return matches, cobra.ShellCompDirectiveNoFileComp</span>
}

// existingVariableCompletion provides completion for existing variable names
func existingVariableCompletion(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
    // Get environment from flag
    env, _ := cmd.Flags().GetString("env")
    if env == "" </span><span class="cov0" title="0">{
        env = "development"
    }</span>

    // Get storage backend
    <span class="cov0" title="0">store, err := storage.GetBackend(env)
    if err != nil </span><span class="cov0" title="0">{
        return nil, cobra.ShellCompDirectiveError
    }</span>
    <span class="cov0" title="0">defer store.Close()

    // Get all variable names
    keys, err := store.List()
    if err != nil </span><span class="cov0" title="0">{
        return nil, cobra.ShellCompDirectiveError
    }</span>

    <span class="cov0" title="0">var matches []string
    for _, key := range keys </span><span class="cov0" title="0">{
        if strings.HasPrefix(strings.ToUpper(key), strings.ToUpper(toComplete)) </span><span class="cov0" title="0">{
            matches = append(matches, key)
        }</span>
    }

    <span class="cov0" title="0">return matches, cobra.ShellCompDirectiveNoFileComp</span>
}

// patternCompletion provides completion for pattern flags
func patternCompletion(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
    patterns := []string{
        "*",
        "API_*",
        "AWS_*",
        "DATABASE_*",
        "REDIS_*",
        "SMTP_*",
        "*_KEY",
        "*_SECRET",
        "*_URL",
        "*_TOKEN",
    }

    var matches []string
    for _, pattern := range patterns </span><span class="cov0" title="0">{
        if strings.HasPrefix(pattern, toComplete) </span><span class="cov0" title="0">{
            matches = append(matches, pattern)
        }</span>
    }

    <span class="cov0" title="0">return matches, cobra.ShellCompDirectiveNoFileComp</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
    "os"
    "runtime"

    "github.com/spf13/cobra"
    "github.com/spf13/viper"
    "github.com/fatih/color"

    "github.com/vaultenv/vaultenv-cli/internal/ui"
)

// BuildInfo contains version information passed from main
type BuildInfo struct {
    Version   string
    Commit    string
    BuildTime string
    BuiltBy   string
}

var (
    // Global flags that affect all commands
    cfgFile     string
    noColor     bool
    verbose     bool

    // Build information
    buildInfo   BuildInfo

    // Root command definition
    rootCmd = &amp;cobra.Command{
        Use:   "vaultenv-cli",
        Short: "🔐 Secure environment variable management for modern teams",

        // Long description shows when users run 'vaultenv-cli help'
        Long: `vaultenv-cli - Enterprise-grade environment variable management

vaultenv-cli makes managing environment variables across different environments
as simple as a single command, while maintaining bank-level security.

Perfect for teams who are tired of:
  • Manually syncing .env files
  • Sharing secrets through Slack
  • Breaking production with wrong configs
  • Not knowing who changed what and when`,

        // PersistentPreRun executes before any subcommand
        PersistentPreRun: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
            // Set UI output to command's output
            ui.SetOutput(cmd.OutOrStdout(), cmd.ErrOrStderr())

            // Configure color output based on flags and environment
            configureColorOutput()

            // Initialize configuration
            initializeConfig()

            // Show version info in verbose mode
            if verbose </span><span class="cov0" title="0">{
                ui.Debug("vaultenv-cli %s (commit: %s, built: %s)",
                    buildInfo.Version, buildInfo.Commit, buildInfo.BuildTime)
            }</span>
        },

        // Don't show errors twice
        SilenceErrors: true,

        // Don't show usage on errors automatically
        SilenceUsage: true,
    }
)

// Execute runs the root command
func Execute(info BuildInfo) error <span class="cov0" title="0">{
    buildInfo = info

    // Add all subcommands
    addCommands()

    // Execute the command tree
    if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
        // Handle errors with helpful messages
        handleError(err)
        return err
    }</span>

    <span class="cov0" title="0">return nil</span>
}

// NewRootCommand creates a new root command for testing
func NewRootCommand() *cobra.Command <span class="cov8" title="1">{
    cmd := &amp;cobra.Command{
        Use:   "vaultenv-cli",
        Short: "🔐 Secure environment variable management for modern teams",
        Long: rootCmd.Long,
        PersistentPreRun: func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
            // Set UI output to command's output
            ui.SetOutput(cmd.OutOrStdout(), cmd.ErrOrStderr())

            // Configure color output based on flags and environment
            configureColorOutput()

            // Initialize configuration
            initializeConfig()

            // Show version info in verbose mode
            if verbose </span><span class="cov0" title="0">{
                ui.Debug("vaultenv-cli %s (commit: %s, built: %s)",
                    buildInfo.Version, buildInfo.Commit, buildInfo.BuildTime)
            }</span>
        },
        SilenceErrors: true,
        SilenceUsage: true,
    }

    // Define global flags
    <span class="cov8" title="1">cmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "",
        "config file (default: $HOME/.vaultenv-cli/config.yaml)")
    cmd.PersistentFlags().BoolVar(&amp;noColor, "no-color", false,
        "disable colored output")
    cmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false,
        "enable verbose output")

    // Add all subcommands
    cmd.AddCommand(newVersionCommand())
    cmd.AddCommand(newSetCommand())
    cmd.AddCommand(newGetCommand())
    cmd.AddCommand(newListCommand())
    cmd.AddCommand(newInitCommand())
    cmd.AddCommand(newCompletionCommand())

    return cmd</span>
}

func init() <span class="cov8" title="1">{
    // Define global flags
    rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "",
        "config file (default: $HOME/.vaultenv-cli/config.yaml)")

    rootCmd.PersistentFlags().BoolVar(&amp;noColor, "no-color", false,
        "disable colored output")

    rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false,
        "enable verbose output")

    // Bind flags to viper for configuration management
    viper.BindPFlag("no_color", rootCmd.PersistentFlags().Lookup("no-color"))
    viper.BindPFlag("verbose", rootCmd.PersistentFlags().Lookup("verbose"))
}</span>

func configureColorOutput() <span class="cov8" title="1">{
    // Respect user preferences and environment
    if noColor || os.Getenv("NO_COLOR") != "" </span><span class="cov0" title="0">{
        color.NoColor = true
        return
    }</span>

    // Detect if we're in a CI environment
    <span class="cov8" title="1">if os.Getenv("CI") != "" </span><span class="cov0" title="0">{
        color.NoColor = true
        return
    }</span>

    // Windows requires special handling for color support
    <span class="cov8" title="1">if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
        // Color package handles Windows automatically
        return
    }</span>
}

func initializeConfig() <span class="cov8" title="1">{
    if cfgFile != "" </span><span class="cov0" title="0">{
        // Use config file from flag
        viper.SetConfigFile(cfgFile)
    }</span> else<span class="cov8" title="1"> {
        // Search for config in standard locations
        viper.SetConfigName("config")
        viper.SetConfigType("yaml")

        // Add search paths in order of precedence
        viper.AddConfigPath(".")                          // Current directory
        viper.AddConfigPath("$HOME/.vaultenv-cli")       // User config directory
        viper.AddConfigPath("/etc/vaultenv-cli")         // System config directory
    }</span>

    // Environment variables override config file
    <span class="cov8" title="1">viper.SetEnvPrefix("vaultenv-cli")
    viper.AutomaticEnv()

    // Read config file if it exists
    if err := viper.ReadInConfig(); err == nil &amp;&amp; verbose </span><span class="cov0" title="0">{
        ui.Debug("Using config file: %s", viper.ConfigFileUsed())
    }</span>
}

func handleError(err error) <span class="cov0" title="0">{
    // This is where we make errors helpful, not frustrating
    ui.HandleError(err)
}</span>

func addCommands() <span class="cov0" title="0">{
    // Add all subcommands
    rootCmd.AddCommand(newVersionCommand())
    rootCmd.AddCommand(newSetCommand())
    rootCmd.AddCommand(newGetCommand())
    rootCmd.AddCommand(newListCommand())
    rootCmd.AddCommand(newInitCommand())
    rootCmd.AddCommand(newCompletionCommand())
}</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
    "fmt"
    "strings"

    "github.com/spf13/cobra"

    "github.com/vaultenv/vaultenv-cli/internal/ui"
    "github.com/vaultenv/vaultenv-cli/pkg/storage"
)

func newGetCommand() *cobra.Command <span class="cov8" title="1">{
    var (
        environment string
        export      bool
        quiet       bool
    )

    cmd := &amp;cobra.Command{
        Use:   "get KEY [KEY...]",
        Short: "Get environment variable values",
        Long: `Get the values of one or more environment variables.

By default, prints the variable in KEY=VALUE format.
Use --quiet to print only the value (useful for scripts).
Use --export to print in shell export format.`,

        Example: `  # Get a single variable
  vaultenv-cli get DATABASE_URL

  # Get multiple variables
  vaultenv-cli get API_KEY DATABASE_URL

  # Get from specific environment
  vaultenv-cli get API_KEY --env production

  # Get value only (for scripts)
  vaultenv-cli get API_KEY --quiet

  # Export format
  vaultenv-cli get API_KEY --export`,

        Args: cobra.MinimumNArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
            return runGet(cmd, args, environment, export, quiet)
        }</span>,
    }

    // Add command-specific flags
    <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;environment, "env", "e", "development",
        "environment to get variables from")
    cmd.Flags().BoolVarP(&amp;export, "export", "x", false,
        "output in shell export format")
    cmd.Flags().BoolVarP(&amp;quiet, "quiet", "q", false,
        "output only values (no keys)")

    // Register completion functions
    cmd.RegisterFlagCompletionFunc("env", environmentCompletion)
    
    // Register positional argument completion for existing variables
    cmd.ValidArgsFunction = existingVariableCompletion

    return cmd</span>
}

func runGet(cmd *cobra.Command, keys []string, environment string, export, quiet bool) error <span class="cov8" title="1">{
    // Get storage backend
    store, err := storage.GetBackend(environment)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("failed to initialize storage: %w", err)
    }</span>
    <span class="cov8" title="1">defer store.Close()

    // Track if we found any variables
    found := false

    // Get each requested variable
    for _, key := range keys </span><span class="cov8" title="1">{
        value, err := store.Get(key)
        if err != nil </span><span class="cov8" title="1">{
            if err == storage.ErrNotFound </span><span class="cov8" title="1">{
                ui.Warning("Variable %s not found", key)
                continue</span>
            }
            <span class="cov0" title="0">return fmt.Errorf("failed to get %s: %w", key, err)</span>
        }

        <span class="cov8" title="1">found = true

        // Format output based on flags
        if quiet </span><span class="cov8" title="1">{
            fmt.Fprintln(cmd.OutOrStdout(), value)
        }</span> else<span class="cov8" title="1"> if export </span><span class="cov8" title="1">{
            fmt.Fprintf(cmd.OutOrStdout(), "export %s=\"%s\"\n", key, escapeShellValue(value))
        }</span> else<span class="cov8" title="1"> {
            fmt.Fprintf(cmd.OutOrStdout(), "%s=%s\n", key, value)
        }</span>
    }

    <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
        return fmt.Errorf("no variables found")
    }</span>

    <span class="cov8" title="1">return nil</span>
}

// escapeShellValue escapes a value for shell export
func escapeShellValue(value string) string <span class="cov8" title="1">{
    // Escape backslashes first (must be done before other escapes)
    value = strings.ReplaceAll(value, "\\", "\\\\")
    // Escape double quotes
    value = strings.ReplaceAll(value, "\"", "\\\"")
    // Escape dollar signs
    value = strings.ReplaceAll(value, "$", "\\$")
    // Escape backticks
    value = strings.ReplaceAll(value, "`", "\\`")
    return value
}</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
    "fmt"
    "os"
    "path/filepath"

    "github.com/spf13/cobra"
    "github.com/AlecAivazis/survey/v2"

    "github.com/vaultenv/vaultenv-cli/internal/ui"
)

func newInitCommand() *cobra.Command <span class="cov8" title="1">{
    var (
        force bool
        name  string
    )

    cmd := &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize a new vaultenv project",
        Long: `Initialize a new vaultenv project in the current directory.

This command creates:
  • .vaultenv/config.yaml - Project configuration
  • .vaultenv/.gitignore - Git ignore rules
  • .env.example - Example environment file`,

        Example: `  # Initialize in current directory
  vaultenv-cli init

  # Initialize with project name
  vaultenv-cli init --name myproject

  # Force overwrite existing configuration
  vaultenv-cli init --force`,

        RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
            return runInit(name, force)
        }</span>,
    }

    // Add command-specific flags
    <span class="cov8" title="1">cmd.Flags().BoolVarP(&amp;force, "force", "f", false,
        "overwrite existing configuration")
    cmd.Flags().StringVarP(&amp;name, "name", "n", "",
        "project name (defaults to directory name)")

    return cmd</span>
}

func runInit(projectName string, force bool) error <span class="cov0" title="0">{
    // Get current directory
    currentDir, err := os.Getwd()
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("failed to get current directory: %w", err)
    }</span>

    // Default project name to directory name
    <span class="cov0" title="0">if projectName == "" </span><span class="cov0" title="0">{
        projectName = filepath.Base(currentDir)
    }</span>

    // Check if already initialized
    <span class="cov0" title="0">configDir := filepath.Join(currentDir, ".vaultenv")
    configFile := filepath.Join(configDir, "config.yaml")

    if _, err := os.Stat(configFile); err == nil &amp;&amp; !force </span><span class="cov0" title="0">{
        return fmt.Errorf("project already initialized. Use --force to overwrite")
    }</span>

    // Collect project information
    <span class="cov0" title="0">var answers struct {
        ProjectName  string
        Description  string
        Environments []string
    }

    questions := []*survey.Question{
        {
            Name: "ProjectName",
            Prompt: &amp;survey.Input{
                Message: "Project name:",
                Default: projectName,
            },
            Validate: survey.Required,
        },
        {
            Name: "Description",
            Prompt: &amp;survey.Input{
                Message: "Project description:",
                Default: "Environment configuration for " + projectName,
            },
        },
        {
            Name: "Environments",
            Prompt: &amp;survey.MultiSelect{
                Message: "Select environments to create:",
                Options: []string{"development", "staging", "production", "testing"},
                Default: []string{"development", "staging", "production"},
            },
        },
    }

    if err := survey.Ask(questions, &amp;answers); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // Create .vaultenv directory
    <span class="cov0" title="0">ui.StartProgress("Creating project structure", func() error </span><span class="cov0" title="0">{
        return os.MkdirAll(configDir, 0755)
    }</span>)

    // Create config file
    <span class="cov0" title="0">configContent := fmt.Sprintf(`# vaultenv Configuration
# Project: %s

project:
  name: %s
  description: %s

# Environments
environments:
`, answers.ProjectName, answers.ProjectName, answers.Description)

    for _, env := range answers.Environments </span><span class="cov0" title="0">{
        configContent += fmt.Sprintf("  - %s\n", env)
    }</span>

    <span class="cov0" title="0">configContent += `
# Security settings
security:
  # Encryption algorithm (aes-gcm-256 or chacha20-poly1305)
  algorithm: aes-gcm-256
  
  # Key derivation settings
  key_derivation:
    iterations: 3
    memory: 65536  # 64MB
    threads: 4

# Storage settings
storage:
  # Backend type (file, git, or cloud)
  type: file
  
  # File storage settings
  file:
    path: .vaultenv/data

# Sync settings
sync:
  # Enable automatic sync
  enabled: false
  
  # Sync interval (in seconds)
  interval: 300
`

    err = ui.StartProgress("Creating configuration", func() error </span><span class="cov0" title="0">{
        return os.WriteFile(configFile, []byte(configContent), 0644)
    }</span>)
    <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // Create .gitignore
    <span class="cov0" title="0">gitignoreContent := `# vaultenv files
*.enc
*.key
.vaultenv/data/
.vaultenv/keys/
.vaultenv/tmp/

# Local environment files
.env
.env.local
.env.*.local

# But keep examples
!.env.example
!.env.*.example
`

    err = ui.StartProgress("Creating .gitignore", func() error </span><span class="cov0" title="0">{
        return os.WriteFile(filepath.Join(configDir, ".gitignore"), []byte(gitignoreContent), 0644)
    }</span>)
    <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // Create .env.example
    <span class="cov0" title="0">envExampleContent := `# Example environment configuration
# Copy this file to .env and update with your values

# Database
DATABASE_URL=postgres://user:password@localhost:5432/dbname

# API Keys
API_KEY=your-api-key-here
API_SECRET=your-api-secret-here

# Application
APP_ENV=development
APP_DEBUG=true
APP_PORT=3000

# External Services
REDIS_URL=redis://localhost:6379
SMTP_HOST=smtp.example.com
SMTP_PORT=587
`

    err = ui.StartProgress("Creating .env.example", func() error </span><span class="cov0" title="0">{
        return os.WriteFile(filepath.Join(currentDir, ".env.example"), []byte(envExampleContent), 0644)
    }</span>)
    <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // Success message
    <span class="cov0" title="0">ui.Success("Project initialized successfully!")
    fmt.Println()
    ui.Info("Next steps:")
    fmt.Println("  1. Review .vaultenv/config.yaml")
    fmt.Println("  2. Copy .env.example to .env and add your variables")
    fmt.Println("  3. Run 'vaultenv-cli set KEY=VALUE' to store variables")
    fmt.Println("  4. Commit .vaultenv/config.yaml and .env.example to git")

    return nil</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
    "fmt"
    "sort"
    "strings"

    "github.com/spf13/cobra"

    "github.com/vaultenv/vaultenv-cli/internal/ui"
    "github.com/vaultenv/vaultenv-cli/pkg/storage"
)

func newListCommand() *cobra.Command <span class="cov8" title="1">{
    var (
        environment string
        showValues  bool
        pattern     string
    )

    cmd := &amp;cobra.Command{
        Use:   "list",
        Short: "List environment variables",
        Long: `List all environment variables in the specified environment.

By default, only variable names are shown for security.
Use --values to also display the values.`,

        Example: `  # List all variables
  vaultenv-cli list

  # List with values
  vaultenv-cli list --values

  # List from specific environment
  vaultenv-cli list --env production

  # Filter by pattern
  vaultenv-cli list --pattern "API_*"`,

        RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
            return runList(cmd, environment, showValues, pattern)
        }</span>,
    }

    // Add command-specific flags
    <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;environment, "env", "e", "development",
        "environment to list variables from")
    cmd.Flags().BoolVar(&amp;showValues, "values", false,
        "show variable values (use with caution)")
    cmd.Flags().StringVarP(&amp;pattern, "pattern", "p", "",
        "filter variables by pattern (supports wildcards)")

    // Register completion functions
    cmd.RegisterFlagCompletionFunc("env", environmentCompletion)
    cmd.RegisterFlagCompletionFunc("pattern", patternCompletion)

    return cmd</span>
}

func runList(cmd *cobra.Command, environment string, showValues bool, pattern string) error <span class="cov8" title="1">{
    // Get storage backend
    store, err := storage.GetBackend(environment)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("failed to initialize storage: %w", err)
    }</span>
    <span class="cov8" title="1">defer store.Close()

    // Get all variable names
    keys, err := store.List()
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("failed to list variables: %w", err)
    }</span>

    <span class="cov8" title="1">if len(keys) == 0 </span><span class="cov8" title="1">{
        ui.Info("No variables found in %s environment", environment)
        return nil
    }</span>

    // Filter by pattern if provided
    <span class="cov8" title="1">if pattern != "" </span><span class="cov8" title="1">{
        keys = filterKeys(keys, pattern)
        if len(keys) == 0 </span><span class="cov8" title="1">{
            ui.Info("No variables matching pattern '%s'", pattern)
            return nil
        }</span>
    }

    // Sort keys for consistent output
    <span class="cov8" title="1">sort.Strings(keys)

    // Display header
    ui.Header(fmt.Sprintf("Environment: %s", environment))
    fmt.Fprintln(cmd.OutOrStdout())

    // Display variables
    if showValues </span><span class="cov8" title="1">{
        // Show as table with values
        maxKeyLen := 0
        for _, key := range keys </span><span class="cov8" title="1">{
            if len(key) &gt; maxKeyLen </span><span class="cov8" title="1">{
                maxKeyLen = len(key)
            }</span>
        }

        <span class="cov8" title="1">for _, key := range keys </span><span class="cov8" title="1">{
            value, err := store.Get(key)
            if err != nil </span><span class="cov0" title="0">{
                ui.Warning("Failed to get %s: %v", key, err)
                continue</span>
            }

            // Truncate long values for display
            <span class="cov8" title="1">displayValue := value
            if len(displayValue) &gt; 50 </span><span class="cov8" title="1">{
                displayValue = displayValue[:47] + "..."
            }</span>

            <span class="cov8" title="1">fmt.Fprintf(cmd.OutOrStdout(), "%-*s = %s\n", maxKeyLen, key, displayValue)</span>
        }
    } else<span class="cov8" title="1"> {
        // Show only keys
        for _, key := range keys </span><span class="cov8" title="1">{
            fmt.Fprintln(cmd.OutOrStdout(), key)
        }</span>
    }

    <span class="cov8" title="1">fmt.Fprintln(cmd.OutOrStdout())
    ui.Info("Total: %d variable(s)", len(keys))

    return nil</span>
}

// filterKeys filters keys by pattern (supports * wildcard)
func filterKeys(keys []string, pattern string) []string <span class="cov8" title="1">{
    filtered := []string{}  // Initialize as empty slice, not nil
    for _, key := range keys </span><span class="cov8" title="1">{
        if matched, _ := matchPattern(key, pattern); matched </span><span class="cov8" title="1">{
            filtered = append(filtered, key)
        }</span>
    }
    <span class="cov8" title="1">return filtered</span>
}

// matchPattern is a simple pattern matcher
func matchPattern(s, pattern string) (bool, error) <span class="cov8" title="1">{
    // Handle exact match
    if !strings.Contains(pattern, "*") </span><span class="cov8" title="1">{
        return s == pattern, nil
    }</span>

    // Convert pattern to a simple glob pattern
    // For now, we'll use simple string matching instead of regex
    
    // Use simple string matching for common patterns
    <span class="cov8" title="1">if pattern == "*" </span><span class="cov8" title="1">{
        return true, nil
    }</span>
    
    <span class="cov8" title="1">if strings.HasPrefix(pattern, "*") &amp;&amp; strings.HasSuffix(pattern, "*") </span><span class="cov8" title="1">{
        // *substring*
        substring := pattern[1:len(pattern)-1]
        return strings.Contains(s, substring), nil
    }</span>
    
    <span class="cov8" title="1">if strings.HasPrefix(pattern, "*") </span><span class="cov8" title="1">{
        // *suffix
        suffix := pattern[1:]
        return strings.HasSuffix(s, suffix), nil
    }</span>
    
    <span class="cov8" title="1">if strings.HasSuffix(pattern, "*") </span><span class="cov8" title="1">{
        // prefix*
        prefix := pattern[:len(pattern)-1]
        return strings.HasPrefix(s, prefix), nil
    }</span>
    
    // For more complex patterns, use simple matching
    <span class="cov8" title="1">parts := strings.Split(pattern, "*")
    
    // Check if string starts with the first part
    if parts[0] != "" &amp;&amp; !strings.HasPrefix(s, parts[0]) </span><span class="cov8" title="1">{
        return false, nil
    }</span>
    
    // Check if string ends with the last part
    <span class="cov8" title="1">if parts[len(parts)-1] != "" &amp;&amp; !strings.HasSuffix(s, parts[len(parts)-1]) </span><span class="cov8" title="1">{
        return false, nil
    }</span>
    
    // For patterns like "prefix*middle*suffix", we need more complex matching
    // For now, return true if all parts exist in order
    <span class="cov8" title="1">remaining := s
    for i, part := range parts </span><span class="cov8" title="1">{
        if part == "" </span><span class="cov0" title="0">{
            continue</span>
        }
        
        <span class="cov8" title="1">idx := strings.Index(remaining, part)
        if idx == -1 </span><span class="cov0" title="0">{
            return false, nil
        }</span>
        
        // For the first part, it must be at the beginning
        <span class="cov8" title="1">if i == 0 &amp;&amp; idx != 0 </span><span class="cov0" title="0">{
            return false, nil
        }</span>
        
        <span class="cov8" title="1">remaining = remaining[idx+len(part):]</span>
    }
    
    <span class="cov8" title="1">return true, nil</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
    "fmt"
    "strings"

    "github.com/spf13/cobra"
    "github.com/AlecAivazis/survey/v2"

    "github.com/vaultenv/vaultenv-cli/internal/ui"
    "github.com/vaultenv/vaultenv-cli/pkg/storage"
)

func newSetCommand() *cobra.Command <span class="cov8" title="1">{
    var (
        environment string
        force      bool
        encrypt    bool
    )

    cmd := &amp;cobra.Command{
        Use:   "set KEY=VALUE [KEY=VALUE...]",
        Short: "Set one or more environment variables",
        Long: `Set environment variables in the specified environment.

Values are encrypted by default before storage. Use --no-encrypt only
for non-sensitive values to improve performance.`,

        Example: `  # Set a single variable
  vaultenv-cli set DATABASE_URL=postgres://localhost/myapp

  # Set multiple variables
  vaultenv-cli set API_KEY=secret DATABASE_URL=postgres://localhost

  # Set in specific environment
  vaultenv-cli set API_KEY=prod-secret --env production

  # Set without encryption (only for non-sensitive data)
  vaultenv-cli set LOG_LEVEL=debug --no-encrypt`,

        Args: cobra.MinimumNArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
            return runSet(args, environment, force, encrypt)
        }</span>,
    }

    // Add command-specific flags
    <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;environment, "env", "e", "development",
        "environment to set variables in")
    cmd.Flags().BoolVarP(&amp;force, "force", "f", false,
        "overwrite existing variables without confirmation")
    cmd.Flags().BoolVar(&amp;encrypt, "encrypt", true,
        "encrypt values before storage")

    // Register completion functions for better UX
    cmd.RegisterFlagCompletionFunc("env", environmentCompletion)
    
    // Register custom validation function that provides variable name suggestions
    cmd.ValidArgsFunction = func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) </span><span class="cov0" title="0">{
        // If toComplete contains '=', don't provide completions (user is typing value)
        if strings.Contains(toComplete, "=") </span><span class="cov0" title="0">{
            return nil, cobra.ShellCompDirectiveNoFileComp
        }</span>
        
        // Otherwise, provide variable name suggestions with '=' appended
        <span class="cov0" title="0">suggestions, directive := variableNameCompletion(cmd, args, toComplete)
        
        // Append '=' to each suggestion for convenience
        for i := range suggestions </span><span class="cov0" title="0">{
            suggestions[i] = suggestions[i] + "="
        }</span>
        
        <span class="cov0" title="0">return suggestions, directive</span>
    }

    <span class="cov8" title="1">return cmd</span>
}

func runSet(args []string, environment string, force bool, encrypt bool) error <span class="cov8" title="1">{
    // Parse KEY=VALUE pairs
    vars, err := parseVariables(args)
    if err != nil </span><span class="cov8" title="1">{
        return fmt.Errorf("invalid variable format: %w", err)
    }</span>

    // Show what we're about to do
    <span class="cov8" title="1">ui.Info("Setting %d variable(s) in %s environment", len(vars), environment)

    // Get storage backend
    store, err := storage.GetBackend(environment)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("failed to initialize storage: %w", err)
    }</span>
    <span class="cov8" title="1">defer store.Close()

    // Process each variable
    for key, value := range vars </span><span class="cov8" title="1">{
        // Check if variable already exists
        exists, err := store.Exists(key)
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to check variable: %w", err)
        }</span>

        // Confirm overwrite if needed
        <span class="cov8" title="1">if exists &amp;&amp; !force </span><span class="cov0" title="0">{
            overwrite := false
            prompt := &amp;survey.Confirm{
                Message: fmt.Sprintf("Variable %s already exists. Overwrite?", key),
                Default: false,
            }

            if err := survey.AskOne(prompt, &amp;overwrite); err != nil </span><span class="cov0" title="0">{
                return err
            }</span>

            <span class="cov0" title="0">if !overwrite </span><span class="cov0" title="0">{
                ui.Info("Skipping %s", key)
                continue</span>
            }
        }

        // Store the variable
        <span class="cov8" title="1">err = ui.StartProgress(fmt.Sprintf("Setting %s", key), func() error </span><span class="cov8" title="1">{
            return store.Set(key, value, encrypt)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("failed to set %s: %w", key, err)
        }</span>
    }

    <span class="cov8" title="1">ui.Success("Variables set successfully")
    return nil</span>
}

func parseVariables(args []string) (map[string]string, error) <span class="cov8" title="1">{
    vars := make(map[string]string)

    for _, arg := range args </span><span class="cov8" title="1">{
        parts := strings.SplitN(arg, "=", 2)
        if len(parts) != 2 </span><span class="cov8" title="1">{
            return nil, fmt.Errorf("invalid format: %s (expected KEY=VALUE)", arg)
        }</span>

        <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
        value := parts[1]  // Don't trim spaces from values - they might be intentional

        // Check for spaces in variable name before validation
        if strings.Contains(key, " ") </span><span class="cov8" title="1">{
            return nil, fmt.Errorf("invalid format: %s (variable names cannot contain spaces)", arg)
        }</span>

        // Validate key format
        <span class="cov8" title="1">if !isValidVariableName(key) </span><span class="cov8" title="1">{
            return nil, fmt.Errorf("invalid variable name: %s", key)
        }</span>

        <span class="cov8" title="1">vars[key] = value</span>
    }

    <span class="cov8" title="1">return vars, nil</span>
}

func isValidVariableName(name string) bool <span class="cov8" title="1">{
    // Environment variable names should follow conventions
    // Must start with letter or underscore
    // Can contain letters, numbers, and underscores
    if len(name) == 0 </span><span class="cov8" title="1">{
        return false
    }</span>

    <span class="cov8" title="1">for i, ch := range name </span><span class="cov8" title="1">{
        if i == 0 </span><span class="cov8" title="1">{
            if !isLetter(ch) &amp;&amp; ch != '_' </span><span class="cov8" title="1">{
                return false
            }</span>
        } else<span class="cov8" title="1"> {
            if !isLetter(ch) &amp;&amp; !isDigit(ch) &amp;&amp; ch != '_' </span><span class="cov8" title="1">{
                return false
            }</span>
        }
    }

    <span class="cov8" title="1">return true</span>
}

func isLetter(ch rune) bool <span class="cov8" title="1">{
    return (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') || (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z')
}</span>

func isDigit(ch rune) bool <span class="cov8" title="1">{
    return ch &gt;= '0' &amp;&amp; ch &lt;= '9'
}</span>

</pre>
		
		<pre class="file" id="file7" style="display: none">package cmd

import (
    "fmt"
    "runtime"

    "github.com/spf13/cobra"
)

func newVersionCommand() *cobra.Command <span class="cov8" title="1">{
    cmd := &amp;cobra.Command{
        Use:   "version",
        Short: "Display version information",
        Long:  `Display detailed version information about vaultenv-cli`,
        Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
            fmt.Printf("vaultenv-cli %s\n", buildInfo.Version)
            fmt.Printf("  Commit:     %s\n", buildInfo.Commit)
            fmt.Printf("  Built:      %s\n", buildInfo.BuildTime)
            fmt.Printf("  Built by:   %s\n", buildInfo.BuiltBy)
            fmt.Printf("  Go version: %s\n", runtime.Version())
            fmt.Printf("  OS/Arch:    %s/%s\n", runtime.GOOS, runtime.GOARCH)
        }</span>,
    }
    <span class="cov8" title="1">return cmd</span>
}</pre>
		
		<pre class="file" id="file8" style="display: none">package test

import (
        "bytes"
        "errors"
        "io"
        "os"
        "path/filepath"
        "testing"

        "github.com/spf13/cobra"
        "github.com/stretchr/testify/require"
        "github.com/vaultenv/vaultenv-cli/pkg/encryption"
        "github.com/vaultenv/vaultenv-cli/pkg/keystore"
        "github.com/vaultenv/vaultenv-cli/pkg/storage"
)

// TestEnvironment provides a complete test environment for CLI testing
type TestEnvironment struct {
        t          *testing.T
        HomeDir    string
        ConfigDir  string
        WorkDir    string
        Storage    storage.Backend
        Keystore   keystore.Keystore
        Encryptor  encryption.Encryptor
        CleanupFns []func()
}

// NewTestEnvironment creates a new test environment with isolated directories
func NewTestEnvironment(t *testing.T) *TestEnvironment <span class="cov8" title="1">{
        t.Helper()

        // Create temporary directories
        tempDir := t.TempDir()
        homeDir := filepath.Join(tempDir, "home")
        configDir := filepath.Join(homeDir, ".vaultenv-cli")
        workDir := filepath.Join(tempDir, "work")

        // Create directories
        require.NoError(t, os.MkdirAll(homeDir, 0755))
        require.NoError(t, os.MkdirAll(configDir, 0755))
        require.NoError(t, os.MkdirAll(workDir, 0755))

        env := &amp;TestEnvironment{
                t:          t,
                HomeDir:    homeDir,
                ConfigDir:  configDir,
                WorkDir:    workDir,
                Storage:    storage.NewMemoryBackend(),
                Keystore:   keystore.NewMockKeystore(),
                Encryptor:  encryption.NewAESGCMEncryptor(),
                CleanupFns: []func(){},
        }

        // Set environment variables
        env.SetEnv("HOME", homeDir)
        env.SetEnv("VAULTENV_CONFIG_DIR", configDir)

        // Set the test backend
        storage.SetTestBackend(env.Storage)
        env.AddCleanup(func() </span><span class="cov8" title="1">{
                storage.ResetTestBackend()
        }</span>)

        // Change to work directory
        <span class="cov8" title="1">oldDir, err := os.Getwd()
        require.NoError(t, err)
        require.NoError(t, os.Chdir(workDir))

        env.AddCleanup(func() </span><span class="cov8" title="1">{
                os.Chdir(oldDir)
        }</span>)

        <span class="cov8" title="1">return env</span>
}

// SetEnv sets an environment variable and schedules cleanup
func (e *TestEnvironment) SetEnv(key, value string) <span class="cov8" title="1">{
        e.t.Helper()
        
        oldValue, exists := os.LookupEnv(key)
        os.Setenv(key, value)
        
        e.AddCleanup(func() </span><span class="cov8" title="1">{
                if exists </span><span class="cov8" title="1">{
                        os.Setenv(key, oldValue)
                }</span> else<span class="cov8" title="1"> {
                        os.Unsetenv(key)
                }</span>
        })
}

// AddCleanup adds a cleanup function to be called when the test finishes
func (e *TestEnvironment) AddCleanup(fn func()) <span class="cov8" title="1">{
        e.CleanupFns = append(e.CleanupFns, fn)
}</span>

// Cleanup runs all cleanup functions
func (e *TestEnvironment) Cleanup() <span class="cov8" title="1">{
        for i := len(e.CleanupFns) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                e.CleanupFns[i]()
        }</span>
}

// WriteFile writes a file in the test environment
func (e *TestEnvironment) WriteFile(path string, content string) <span class="cov0" title="0">{
        e.t.Helper()
        
        fullPath := filepath.Join(e.WorkDir, path)
        dir := filepath.Dir(fullPath)
        
        require.NoError(e.t, os.MkdirAll(dir, 0755))
        require.NoError(e.t, os.WriteFile(fullPath, []byte(content), 0644))
}</span>

// ReadFile reads a file from the test environment
func (e *TestEnvironment) ReadFile(path string) string <span class="cov0" title="0">{
        e.t.Helper()
        
        fullPath := filepath.Join(e.WorkDir, path)
        content, err := os.ReadFile(fullPath)
        require.NoError(e.t, err)
        
        return string(content)
}</span>

// CommandOutput captures the output of a cobra command
type CommandOutput struct {
        Stdout string
        Stderr string
}

// ExecuteCommand executes a cobra command and captures its output
func ExecuteCommand(cmd *cobra.Command, args ...string) (*CommandOutput, error) <span class="cov8" title="1">{
        // Create buffers for output
        stdout := new(bytes.Buffer)
        stderr := new(bytes.Buffer)

        // Set output
        cmd.SetOut(stdout)
        cmd.SetErr(stderr)
        cmd.SetArgs(args)

        // Execute command
        err := cmd.Execute()

        return &amp;CommandOutput{
                Stdout: stdout.String(),
                Stderr: stderr.String(),
        }, err
}</span>

// CaptureStdin temporarily replaces stdin for testing interactive prompts
func CaptureStdin(input string) (restore func()) <span class="cov0" title="0">{
        oldStdin := os.Stdin
        r, w, _ := os.Pipe()
        os.Stdin = r

        // Write input to pipe
        go func() </span><span class="cov0" title="0">{
                defer w.Close()
                io.WriteString(w, input)
        }</span>()

        <span class="cov0" title="0">return func() </span><span class="cov0" title="0">{
                os.Stdin = oldStdin
                r.Close()
        }</span>
}

// AssertFileExists checks if a file exists
func AssertFileExists(t *testing.T, path string) <span class="cov0" title="0">{
        t.Helper()
        _, err := os.Stat(path)
        require.NoError(t, err, "file should exist: %s", path)
}</span>

// AssertFileNotExists checks if a file does not exist
func AssertFileNotExists(t *testing.T, path string) <span class="cov0" title="0">{
        t.Helper()
        _, err := os.Stat(path)
        require.True(t, os.IsNotExist(err), "file should not exist: %s", path)
}</span>

// AssertFileContains checks if a file contains a string
func AssertFileContains(t *testing.T, path string, expected string) <span class="cov0" title="0">{
        t.Helper()
        content, err := os.ReadFile(path)
        require.NoError(t, err)
        require.Contains(t, string(content), expected)
}</span>

// MockStorage creates a pre-populated mock storage for testing
func MockStorage() *storage.MemoryBackend <span class="cov0" title="0">{
        backend := storage.NewMemoryBackend()
        
        // Add some test data
        backend.Set("TEST_VAR", "test_value", false)
        backend.Set("DATABASE_URL", "postgres://localhost/test", false)
        backend.Set("API_KEY", "test-api-key", false)
        
        return backend
}</span>

// ParseVariables is a helper function for testing variable parsing
func ParseVariables(args []string) (map[string]string, error) <span class="cov0" title="0">{
        result := make(map[string]string)
        
        for _, arg := range args </span><span class="cov0" title="0">{
                parts := bytes.SplitN([]byte(arg), []byte("="), 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid format")
                }</span>
                
                <span class="cov0" title="0">key := string(parts[0])
                value := string(parts[1])
                
                // Validate variable name
                if key == "" </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid variable name")
                }</span>
                
                <span class="cov0" title="0">result[key] = value</span>
        }
        
        <span class="cov0" title="0">return result, nil</span>
}</pre>
		
		<pre class="file" id="file9" style="display: none">package ui

import (
    "fmt"
    "strings"
)

// ErrorWithHelp represents an error with helpful context
type ErrorWithHelp struct {
    Message    string
    Suggestion string
    DocsLink   string
    Code       string
}

func (e ErrorWithHelp) Error() string <span class="cov8" title="1">{
    return e.Message
}</span>

// Common errors with helpful suggestions
var commonErrors = map[string]ErrorWithHelp{
    "ENV_NOT_FOUND": {
        Message:    "Environment '%s' not found",
        Suggestion: "Use 'vaultenv-cli env list' to see available environments",
        DocsLink:   "https://docs.vaultenv-cli.io/environments",
    },
    "VAR_NOT_FOUND": {
        Message:    "Variable '%s' not found",
        Suggestion: "Use 'vaultenv-cli list' to see available variables",
        DocsLink:   "https://docs.vaultenv-cli.io/variables",
    },
    "AUTH_REQUIRED": {
        Message:    "Authentication required",
        Suggestion: "Run 'vaultenv-cli auth login' to authenticate",
        DocsLink:   "https://docs.vaultenv-cli.io/authentication",
    },
    "PERMISSION_DENIED": {
        Message:    "Permission denied for operation",
        Suggestion: "Check your access level or contact your team admin",
        DocsLink:   "https://docs.vaultenv-cli.io/permissions",
    },
    "INVALID_CONFIG": {
        Message:    "Invalid configuration: %s",
        Suggestion: "Run 'vaultenv-cli init' to create a valid configuration",
        DocsLink:   "https://docs.vaultenv-cli.io/configuration",
    },
}

// HandleError displays an error with helpful context
func HandleError(err error) <span class="cov8" title="1">{
    if err == nil </span><span class="cov8" title="1">{
        return
    }</span>

    // Check if it's one of our errors with help
    <span class="cov8" title="1">if helpErr, ok := err.(ErrorWithHelp); ok </span><span class="cov8" title="1">{
        displayErrorWithHelp(helpErr)
        return
    }</span>

    // Check for common error patterns
    <span class="cov8" title="1">errStr := err.Error()
    switch </span>{
    case strings.Contains(errStr, "connection refused"):<span class="cov8" title="1">
        displayConnectionError()</span>
    case strings.Contains(errStr, "timeout"):<span class="cov8" title="1">
        displayTimeoutError()</span>
    case strings.Contains(errStr, "permission denied"):<span class="cov8" title="1">
        displayPermissionError()</span>
    default:<span class="cov8" title="1">
        // Generic error display
        Error(err.Error())</span>
    }
}

func displayErrorWithHelp(err ErrorWithHelp) <span class="cov8" title="1">{
    // Display the main error
    Error(err.Message)

    // Add spacing
    fmt.Fprintln(stdout)

    // Show suggestion if available
    if err.Suggestion != "" </span><span class="cov8" title="1">{
        infoColor.Fprintln(stdout, "💡 Suggestion:")
        fmt.Fprintf(stdout, "   %s\n", err.Suggestion)
    }</span>

    // Show docs link if available
    <span class="cov8" title="1">if err.DocsLink != "" </span><span class="cov8" title="1">{
        fmt.Fprintln(stdout)
        mutedColor.Fprintf(stdout, "📚 Learn more: %s\n", err.DocsLink)
    }</span>

    // Show error code for support
    <span class="cov8" title="1">if err.Code != "" </span><span class="cov8" title="1">{
        fmt.Fprintln(stdout)
        mutedColor.Fprintf(stdout, "Error code: %s\n", err.Code)
    }</span>
}

func displayConnectionError() <span class="cov8" title="1">{
    Error("Unable to connect to vaultenv-cli service")
    fmt.Fprintln(stdout)
    infoColor.Fprintln(stdout, "💡 Possible solutions:")
    fmt.Fprintln(stdout, "   1. Check your internet connection")
    fmt.Fprintln(stdout, "   2. Verify the service is running: vaultenv-cli status")
    fmt.Fprintln(stdout, "   3. Check if you're behind a proxy")
    fmt.Fprintln(stdout)
    mutedColor.Fprintln(stdout, "📚 Learn more: https://docs.vaultenv-cli.io/troubleshooting")
}</span>

func displayTimeoutError() <span class="cov8" title="1">{
    Error("Operation timed out")
    fmt.Fprintln(stdout)
    infoColor.Fprintln(stdout, "💡 This might be due to:")
    fmt.Fprintln(stdout, "   • Slow network connection")
    fmt.Fprintln(stdout, "   • Large amount of data")
    fmt.Fprintln(stdout, "   • Server under high load")
    fmt.Fprintln(stdout)
    fmt.Fprintln(stdout, "Try running the command again with --timeout flag")
}</span>

func displayPermissionError() <span class="cov8" title="1">{
    Error("Permission denied")
    fmt.Fprintln(stdout)
    infoColor.Fprintln(stdout, "💡 This might mean:")
    fmt.Fprintln(stdout, "   • You need to authenticate: vaultenv-cli auth login")
    fmt.Fprintln(stdout, "   • You don't have access to this resource")
    fmt.Fprintln(stdout, "   • Your token has expired")
    fmt.Fprintln(stdout)
    mutedColor.Fprintln(stdout, "📚 Learn more: https://docs.vaultenv-cli.io/permissions")
}</span>

// NewError creates an error with helpful context
func NewError(code string, args ...interface{}) error <span class="cov8" title="1">{
    template, exists := commonErrors[code]
    if !exists </span><span class="cov8" title="1">{
        return fmt.Errorf("unknown error: %s", code)
    }</span>

    // Format message with arguments
    <span class="cov8" title="1">message := fmt.Sprintf(template.Message, args...)

    return ErrorWithHelp{
        Message:    message,
        Suggestion: template.Suggestion,
        DocsLink:   template.DocsLink,
        Code:       code,
    }</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package ui

import (
    "fmt"
    "io"
    "os"
    "strings"
    "time"

    "github.com/fatih/color"
    "github.com/briandowns/spinner"
    "github.com/spf13/viper"
)

// Color scheme for consistent output
var (
    // Success is used for positive confirmations
    successColor = color.New(color.FgGreen, color.Bold)

    // Error is used for error messages
    errorColor = color.New(color.FgRed, color.Bold)

    // Warning is used for cautionary messages
    warningColor = color.New(color.FgYellow)

    // Info is used for informational messages
    infoColor = color.New(color.FgCyan)

    // Muted is used for less important information
    mutedColor = color.New(color.FgHiBlack)

    // Header is used for section headers
    headerColor = color.New(color.FgHiWhite, color.Bold)

    // Output writers (can be overridden for testing)
    stdout io.Writer = os.Stdout
    stderr io.Writer = os.Stderr
)

// Success prints a success message with a checkmark
func Success(format string, args ...interface{}) <span class="cov8" title="1">{
    message := fmt.Sprintf(format, args...)
    successColor.Fprintf(stdout, "✓ %s\n", message)
}</span>

// Error prints an error message with an X
func Error(format string, args ...interface{}) <span class="cov8" title="1">{
    message := fmt.Sprintf(format, args...)
    errorColor.Fprintf(stderr, "✗ %s\n", message)
}</span>

// Warning prints a warning message with an exclamation
func Warning(format string, args ...interface{}) <span class="cov8" title="1">{
    message := fmt.Sprintf(format, args...)
    warningColor.Fprintf(stdout, "! %s\n", message)
}</span>

// Info prints an informational message
func Info(format string, args ...interface{}) <span class="cov8" title="1">{
    message := fmt.Sprintf(format, args...)
    infoColor.Fprintf(stdout, "ℹ %s\n", message)
}</span>

// Debug prints debug information (only in verbose mode)
func Debug(format string, args ...interface{}) <span class="cov8" title="1">{
    if !isVerbose() </span><span class="cov8" title="1">{
        return
    }</span>
    <span class="cov8" title="1">message := fmt.Sprintf(format, args...)
    mutedColor.Fprintf(stdout, "› %s\n", message)</span>
}

// Header prints a section header
func Header(text string) <span class="cov8" title="1">{
    fmt.Fprintln(stdout)
    headerColor.Fprintln(stdout, text)
    headerColor.Fprintln(stdout, strings.Repeat("─", len(text)))
}</span>

// Progress indicator for longer operations
type ProgressIndicator struct {
    spinner *spinner.Spinner
    message string
}

// StartProgress begins showing a progress indicator
func StartProgress(message string, work func() error) error <span class="cov8" title="1">{
    // Choose spinner style based on terminal capabilities
    spinnerStyle := spinner.CharSets[14] // Dots style
    if !supportsUnicode() </span><span class="cov8" title="1">{
        spinnerStyle = spinner.CharSets[9] // ASCII style
    }</span>

    <span class="cov8" title="1">s := spinner.New(spinnerStyle, 100*time.Millisecond)
    s.Suffix = " " + message

    // Use color if available
    if !color.NoColor </span><span class="cov8" title="1">{
        s.Color("cyan", "bold")
    }</span>

    // Start spinner
    <span class="cov8" title="1">s.Start()

    // Do the work
    err := work()

    // Stop spinner
    s.Stop()

    // Show result
    if err != nil </span><span class="cov8" title="1">{
        Error("%s failed: %v", message, err)
    }</span> else<span class="cov8" title="1"> {
        Success("%s complete", message)
    }</span>

    <span class="cov8" title="1">return err</span>
}

// Table renders data in a nice table format
func Table(headers []string, rows [][]string) <span class="cov8" title="1">{
    // Calculate column widths
    widths := make([]int, len(headers))
    for i, header := range headers </span><span class="cov8" title="1">{
        widths[i] = len(header)
    }</span>

    <span class="cov8" title="1">for _, row := range rows </span><span class="cov8" title="1">{
        for i, cell := range row </span><span class="cov8" title="1">{
            if i &lt; len(widths) &amp;&amp; len(cell) &gt; widths[i] </span><span class="cov8" title="1">{
                widths[i] = len(cell)
            }</span>
        }
    }

    // Print headers
    <span class="cov8" title="1">headerColor.Fprint(stdout, "┌")
    for i, width := range widths </span><span class="cov8" title="1">{
        headerColor.Fprint(stdout, strings.Repeat("─", width+2))
        if i &lt; len(widths)-1 </span><span class="cov8" title="1">{
            headerColor.Fprint(stdout, "┬")
        }</span>
    }
    <span class="cov8" title="1">headerColor.Fprintln(stdout, "┐")

    headerColor.Fprint(stdout, "│")
    for i, header := range headers </span><span class="cov8" title="1">{
        headerColor.Fprintf(stdout, " %-*s ", widths[i], header)
        headerColor.Fprint(stdout, "│")
    }</span>
    <span class="cov8" title="1">headerColor.Fprintln(stdout)

    // Print separator
    headerColor.Fprint(stdout, "├")
    for i, width := range widths </span><span class="cov8" title="1">{
        headerColor.Fprint(stdout, strings.Repeat("─", width+2))
        if i &lt; len(widths)-1 </span><span class="cov8" title="1">{
            headerColor.Fprint(stdout, "┼")
        }</span>
    }
    <span class="cov8" title="1">headerColor.Fprintln(stdout, "┤")

    // Print rows
    for _, row := range rows </span><span class="cov8" title="1">{
        fmt.Fprint(stdout, "│")
        for i, cell := range row </span><span class="cov8" title="1">{
            if i &lt; len(widths) </span><span class="cov8" title="1">{
                fmt.Fprintf(stdout, " %-*s ", widths[i], cell)
                fmt.Fprint(stdout, "│")
            }</span>
        }
        <span class="cov8" title="1">fmt.Fprintln(stdout)</span>
    }

    // Print footer
    <span class="cov8" title="1">fmt.Fprint(stdout, "└")
    for i, width := range widths </span><span class="cov8" title="1">{
        fmt.Fprint(stdout, strings.Repeat("─", width+2))
        if i &lt; len(widths)-1 </span><span class="cov8" title="1">{
            fmt.Fprint(stdout, "┴")
        }</span>
    }
    <span class="cov8" title="1">fmt.Fprintln(stdout, "┘")</span>
}


// SetOutput configures the output writers (useful for testing)
func SetOutput(out, err io.Writer) <span class="cov8" title="1">{
    stdout = out
    stderr = err
}</span>

// ResetOutput restores the default output writers
func ResetOutput() <span class="cov8" title="1">{
    stdout = os.Stdout
    stderr = os.Stderr
}</span>

// Helper functions
func isVerbose() bool <span class="cov8" title="1">{
    return viper.GetBool("verbose")
}</span>

func supportsUnicode() bool <span class="cov8" title="1">{
    // Check if terminal supports Unicode
    lang := os.Getenv("LANG")

    // Basic check - can be improved
    return strings.Contains(lang, "UTF-8") || strings.Contains(lang, "utf8")
}</pre>
		
		<pre class="file" id="file11" style="display: none">package encryption

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/base64"
        "fmt"
        "io"

        "golang.org/x/crypto/argon2"
)

// AESGCMEncryptor implements AES-256-GCM encryption
type AESGCMEncryptor struct {
        // Key derivation parameters (chosen for security/performance balance)
        iterations uint32
        memory     uint32
        threads    uint8
        keyLength  uint32
}

// NewAESGCMEncryptor creates a new AES-GCM encryptor with secure defaults
func NewAESGCMEncryptor() *AESGCMEncryptor <span class="cov8" title="1">{
        return &amp;AESGCMEncryptor{
                iterations: 3,         // Number of iterations
                memory:     64 * 1024, // Memory in KiB (64 MB)
                threads:    4,         // Number of threads
                keyLength:  32,        // Key length in bytes (256 bits)
        }
}</span>

// Algorithm returns the algorithm identifier
func (e *AESGCMEncryptor) Algorithm() string <span class="cov8" title="1">{
        return "aes-gcm-256"
}</span>

// GenerateSalt creates a cryptographically secure random salt
func (e *AESGCMEncryptor) GenerateSalt() ([]byte, error) <span class="cov8" title="1">{
        salt := make([]byte, 32) // 256-bit salt
        if _, err := io.ReadFull(rand.Reader, salt); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate salt: %w", err)
        }</span>
        <span class="cov8" title="1">return salt, nil</span>
}

// GenerateKey derives an encryption key from a password using Argon2id
func (e *AESGCMEncryptor) GenerateKey(password string, salt []byte) []byte <span class="cov8" title="1">{
        // Argon2id is the recommended algorithm for password hashing
        // It provides both side-channel resistance (from Argon2i)
        // and GPU cracking resistance (from Argon2d)
        return argon2.IDKey(
                []byte(password),
                salt,
                e.iterations,
                e.memory,
                e.threads,
                e.keyLength,
        )
}</span>

// Encrypt encrypts plaintext using AES-256-GCM
func (e *AESGCMEncryptor) Encrypt(plaintext []byte, key []byte) ([]byte, error) <span class="cov8" title="1">{
        // Validate key length
        if len(key) != 32 </span><span class="cov8" title="1">{
                return nil, ErrInvalidKey
        }</span>

        // Create cipher block
        <span class="cov8" title="1">block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        // Create GCM mode
        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        // Generate nonce
        <span class="cov8" title="1">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate nonce: %w", err)
        }</span>

        // Encrypt data
        // Prepend nonce to ciphertext for storage
        <span class="cov8" title="1">ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)

        return ciphertext, nil</span>
}

// Decrypt decrypts ciphertext encrypted with AES-256-GCM
func (e *AESGCMEncryptor) Decrypt(ciphertext []byte, key []byte) ([]byte, error) <span class="cov8" title="1">{
        // Validate key length
        if len(key) != 32 </span><span class="cov8" title="1">{
                return nil, ErrInvalidKey
        }</span>

        // Create cipher block
        <span class="cov8" title="1">block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        // Create GCM mode
        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        // Validate ciphertext length
        <span class="cov8" title="1">nonceSize := gcm.NonceSize()
        if len(ciphertext) &lt; nonceSize </span><span class="cov8" title="1">{
                return nil, ErrInvalidData
        }</span>

        // Extract nonce and actual ciphertext
        <span class="cov8" title="1">nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]

        // Decrypt data
        plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, ErrDecryptionFailed
        }</span>

        <span class="cov8" title="1">return plaintext, nil</span>
}

// Helper functions for string encoding

// EncryptString encrypts a string and returns base64-encoded result
func (e *AESGCMEncryptor) EncryptString(plaintext string, key []byte) (string, error) <span class="cov8" title="1">{
        ciphertext, err := e.Encrypt([]byte(plaintext), key)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return base64.StdEncoding.EncodeToString(ciphertext), nil</span>
}

// DecryptString decrypts a base64-encoded string
func (e *AESGCMEncryptor) DecryptString(ciphertext string, key []byte) (string, error) <span class="cov8" title="1">{
        data, err := base64.StdEncoding.DecodeString(ciphertext)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid base64: %w", err)
        }</span>

        <span class="cov8" title="1">plaintext, err := e.Decrypt(data, key)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return string(plaintext), nil</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">package encryption

import "errors"

// ChaChaEncryptor implements ChaCha20-Poly1305 encryption
// This is a stub implementation for now
type ChaChaEncryptor struct{}

// NewChaChaEncryptor creates a new ChaCha20-Poly1305 encryptor
func NewChaChaEncryptor() *ChaChaEncryptor <span class="cov0" title="0">{
        return &amp;ChaChaEncryptor{}
}</span>

// Algorithm returns the algorithm identifier
func (e *ChaChaEncryptor) Algorithm() string <span class="cov0" title="0">{
        return "chacha20-poly1305"
}</span>

// GenerateSalt creates a cryptographically secure random salt
func (e *ChaChaEncryptor) GenerateSalt() ([]byte, error) <span class="cov0" title="0">{
        return nil, errors.New("ChaCha20-Poly1305 not yet implemented")
}</span>

// GenerateKey derives an encryption key from a password
func (e *ChaChaEncryptor) GenerateKey(password string, salt []byte) []byte <span class="cov0" title="0">{
        return nil
}</span>

// Encrypt encrypts plaintext using ChaCha20-Poly1305
func (e *ChaChaEncryptor) Encrypt(plaintext []byte, key []byte) ([]byte, error) <span class="cov0" title="0">{
        return nil, errors.New("ChaCha20-Poly1305 not yet implemented")
}</span>

// Decrypt decrypts ciphertext encrypted with ChaCha20-Poly1305
func (e *ChaChaEncryptor) Decrypt(ciphertext []byte, key []byte) ([]byte, error) <span class="cov0" title="0">{
        return nil, errors.New("ChaCha20-Poly1305 not yet implemented")
}</pre>
		
		<pre class="file" id="file13" style="display: none">package encryption

import (
        "errors"
)

// Common errors
var (
        ErrInvalidKey       = errors.New("invalid encryption key")
        ErrDecryptionFailed = errors.New("decryption failed")
        ErrInvalidData      = errors.New("invalid encrypted data")
)

// Encryptor defines the interface for encryption implementations
// This allows us to swap algorithms if needed while maintaining compatibility
type Encryptor interface {
        // Encrypt encrypts plaintext using the provided key
        Encrypt(plaintext []byte, key []byte) ([]byte, error)

        // Decrypt decrypts ciphertext using the provided key
        Decrypt(ciphertext []byte, key []byte) ([]byte, error)

        // GenerateKey derives an encryption key from a password
        GenerateKey(password string, salt []byte) []byte

        // GenerateSalt creates a new random salt
        GenerateSalt() ([]byte, error)

        // Algorithm returns the name of the encryption algorithm
        Algorithm() string
}

// Metadata contains information about encrypted data
// This helps with key rotation and algorithm upgrades
type Metadata struct {
        Algorithm string `json:"algorithm"`
        Version   int    `json:"version"`
        Salt      []byte `json:"salt"`
        Nonce     []byte `json:"nonce,omitempty"`
        CreatedAt int64  `json:"created_at"`
}

// EncryptedData represents encrypted content with metadata
type EncryptedData struct {
        Metadata   Metadata `json:"metadata"`
        Ciphertext []byte   `json:"ciphertext"`
}

// Factory creates an encryptor based on algorithm name
func NewEncryptor(algorithm string) (Encryptor, error) <span class="cov0" title="0">{
        switch algorithm </span>{
        case "aes-gcm-256":<span class="cov0" title="0">
                return NewAESGCMEncryptor(), nil</span>
        case "chacha20-poly1305":<span class="cov0" title="0">
                return NewChaChaEncryptor(), nil</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("unsupported algorithm: " + algorithm)</span>
        }
}

// DefaultEncryptor returns the default encryption algorithm
func DefaultEncryptor() Encryptor <span class="cov8" title="1">{
        return NewAESGCMEncryptor()
}</pre>
		
		<pre class="file" id="file14" style="display: none">package keystore

import (
        "fmt"
        "runtime"

        "github.com/99designs/keyring"
)

// Keystore provides secure storage for encryption keys
type Keystore interface {
        // Store saves a key securely
        Store(service, account string, data []byte) error

        // Retrieve gets a stored key
        Retrieve(service, account string) ([]byte, error)

        // Delete removes a stored key
        Delete(service, account string) error

        // List returns all stored keys for a service
        List(service string) ([]string, error)
}

// OSKeystore uses the operating system's secure storage
type OSKeystore struct {
        ring keyring.Keyring
}

// NewOSKeystore creates a keystore using OS facilities
func NewOSKeystore(appName string) (*OSKeystore, error) <span class="cov0" title="0">{
        // Configure keyring with appropriate backends for each OS
        config := keyring.Config{
                ServiceName: appName,

                // Try these backends in order
                AllowedBackends: []keyring.BackendType{
                        keyring.KeychainBackend,      // macOS Keychain
                        keyring.WinCredBackend,       // Windows Credential Manager
                        keyring.SecretServiceBackend, // Linux Secret Service (GNOME/KDE)
                        keyring.KWalletBackend,       // KDE Wallet (legacy)
                        keyring.FileBackend,          // Encrypted file (fallback)
                },

                // Prompt for password if using file backend
                FilePasswordFunc: keyring.TerminalPrompt,

                // Use a consistent file location
                FileDir: "~/.vaultenv-cli/keyring",

                // Key names can contain these characters
                KeychainName: "vaultenv-cli",

                // Windows-specific settings
                WinCredPrefix: "vaultenv-cli",
        }

        ring, err := keyring.Open(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open keyring: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;OSKeystore{ring: ring}, nil</span>
}

// Store saves a key securely
func (k *OSKeystore) Store(service, account string, data []byte) error <span class="cov0" title="0">{
        return k.ring.Set(keyring.Item{
                Key:         k.makeKey(service, account),
                Data:        data,
                Label:       fmt.Sprintf("vaultenv-cli key for %s", account),
                Description: fmt.Sprintf("Encryption key for %s environment", account),
        })
}</span>

// Retrieve gets a stored key
func (k *OSKeystore) Retrieve(service, account string) ([]byte, error) <span class="cov0" title="0">{
        item, err := k.ring.Get(k.makeKey(service, account))
        if err != nil </span><span class="cov0" title="0">{
                if err == keyring.ErrKeyNotFound </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("key not found for %s", account)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to retrieve key: %w", err)</span>
        }

        <span class="cov0" title="0">return item.Data, nil</span>
}

// Delete removes a stored key
func (k *OSKeystore) Delete(service, account string) error <span class="cov0" title="0">{
        err := k.ring.Remove(k.makeKey(service, account))
        if err != nil &amp;&amp; err != keyring.ErrKeyNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete key: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// List returns all stored keys for a service
func (k *OSKeystore) List(service string) ([]string, error) <span class="cov0" title="0">{
        keys, err := k.ring.Keys()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list keys: %w", err)
        }</span>

        <span class="cov0" title="0">var accounts []string
        prefix := service + ":"

        for _, key := range keys </span><span class="cov0" title="0">{
                if len(key) &gt; len(prefix) &amp;&amp; key[:len(prefix)] == prefix </span><span class="cov0" title="0">{
                        account := key[len(prefix):]
                        accounts = append(accounts, account)
                }</span>
        }

        <span class="cov0" title="0">return accounts, nil</span>
}

// makeKey creates a consistent key format
func (k *OSKeystore) makeKey(service, account string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s", service, account)
}</span>

// GetBackend returns the active keyring backend name
func (k *OSKeystore) GetBackend() string <span class="cov0" title="0">{
        // This helps with debugging and user support
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                return "macOS Keychain"</span>
        case "windows":<span class="cov0" title="0">
                return "Windows Credential Manager"</span>
        case "linux":<span class="cov0" title="0">
                // Try to detect which backend is actually in use
                if runtime.GOARCH == "amd64" </span><span class="cov0" title="0">{
                        return "Secret Service"
                }</span>
                <span class="cov0" title="0">return "Encrypted File"</span>
        default:<span class="cov0" title="0">
                return "Encrypted File"</span>
        }
}</pre>
		
		<pre class="file" id="file15" style="display: none">package keystore

import (
        "fmt"
)

// MockKeystore is an in-memory implementation for testing
type MockKeystore struct {
        keys map[string][]byte
}

func NewMockKeystore() *MockKeystore <span class="cov8" title="1">{
        return &amp;MockKeystore{
                keys: make(map[string][]byte),
        }
}</span>

func (m *MockKeystore) Store(service, account string, data []byte) error <span class="cov8" title="1">{
        if m.keys == nil </span><span class="cov0" title="0">{
                m.keys = make(map[string][]byte)
        }</span>
        <span class="cov8" title="1">if len(data) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot store empty data")
        }</span>
        <span class="cov8" title="1">key := fmt.Sprintf("%s:%s", service, account)
        // Store a copy to prevent external modifications
        m.keys[key] = append([]byte(nil), data...)
        return nil</span>
}

func (m *MockKeystore) Retrieve(service, account string) ([]byte, error) <span class="cov8" title="1">{
        if m.keys == nil </span><span class="cov0" title="0">{
                m.keys = make(map[string][]byte)
        }</span>
        <span class="cov8" title="1">key := fmt.Sprintf("%s:%s", service, account)
        data, exists := m.keys[key]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("key not found for %s", account)
        }</span>
        // Return a copy to prevent external modifications
        <span class="cov8" title="1">return append([]byte(nil), data...), nil</span>
}

func (m *MockKeystore) Delete(service, account string) error <span class="cov8" title="1">{
        if m.keys == nil </span><span class="cov0" title="0">{
                m.keys = make(map[string][]byte)
        }</span>
        <span class="cov8" title="1">key := fmt.Sprintf("%s:%s", service, account)
        delete(m.keys, key)
        return nil</span>
}

func (m *MockKeystore) List(service string) ([]string, error) <span class="cov8" title="1">{
        if m.keys == nil </span><span class="cov0" title="0">{
                m.keys = make(map[string][]byte)
        }</span>
        <span class="cov8" title="1">var accounts []string
        prefix := service + ":"
        
        for key := range m.keys </span><span class="cov8" title="1">{
                if len(key) &gt; len(prefix) &amp;&amp; key[:len(prefix)] == prefix </span><span class="cov8" title="1">{
                        account := key[len(prefix):]
                        accounts = append(accounts, account)
                }</span>
        }
        
        <span class="cov8" title="1">return accounts, nil</span>
}</pre>
		
		<pre class="file" id="file16" style="display: none">package storage

import (
    "errors"
)

// Common errors
var (
    ErrNotFound      = errors.New("variable not found")
    ErrAlreadyExists = errors.New("variable already exists")
    ErrInvalidName   = errors.New("invalid variable name")
)

// Backend defines the interface for storage implementations
type Backend interface {
    // Set stores a variable with optional encryption
    Set(key, value string, encrypt bool) error

    // Get retrieves a variable value
    Get(key string) (string, error)

    // Exists checks if a variable exists
    Exists(key string) (bool, error)

    // Delete removes a variable
    Delete(key string) error

    // List returns all variable names
    List() ([]string, error)

    // Close closes the storage backend
    Close() error
}

// testBackend is used for testing to override the default backend
var testBackend Backend

// SetTestBackend sets a backend to use during testing
func SetTestBackend(backend Backend) <span class="cov0" title="0">{
    testBackend = backend
}</span>

// ResetTestBackend clears the test backend
func ResetTestBackend() <span class="cov0" title="0">{
    testBackend = nil
}</span>

// GetBackend returns a storage backend for the given environment
func GetBackend(environment string) (Backend, error) <span class="cov0" title="0">{
    // Use test backend if set
    if testBackend != nil </span><span class="cov0" title="0">{
        return testBackend, nil
    }</span>
    
    // TODO: Implement actual backend selection
    // For now, return a simple in-memory backend
    <span class="cov0" title="0">return NewMemoryBackend(), nil</span>
}</pre>
		
		<pre class="file" id="file17" style="display: none">package storage

import (
    "sync"
)

// MemoryBackend is a simple in-memory storage backend for development
type MemoryBackend struct {
    mu   sync.RWMutex
    data map[string]string
}

// NewMemoryBackend creates a new in-memory storage backend
func NewMemoryBackend() *MemoryBackend <span class="cov8" title="1">{
    return &amp;MemoryBackend{
        data: make(map[string]string),
    }
}</span>

// Set stores a variable
func (m *MemoryBackend) Set(key, value string, encrypt bool) error <span class="cov8" title="1">{
    m.mu.Lock()
    defer m.mu.Unlock()

    // TODO: Implement encryption when encrypt is true
    m.data[key] = value
    return nil
}</span>

// Get retrieves a variable
func (m *MemoryBackend) Get(key string) (string, error) <span class="cov8" title="1">{
    m.mu.RLock()
    defer m.mu.RUnlock()

    value, exists := m.data[key]
    if !exists </span><span class="cov8" title="1">{
        return "", ErrNotFound
    }</span>

    <span class="cov8" title="1">return value, nil</span>
}

// Exists checks if a variable exists
func (m *MemoryBackend) Exists(key string) (bool, error) <span class="cov8" title="1">{
    m.mu.RLock()
    defer m.mu.RUnlock()

    _, exists := m.data[key]
    return exists, nil
}</span>

// Delete removes a variable
func (m *MemoryBackend) Delete(key string) error <span class="cov8" title="1">{
    m.mu.Lock()
    defer m.mu.Unlock()

    delete(m.data, key)
    return nil
}</span>

// List returns all variable names
func (m *MemoryBackend) List() ([]string, error) <span class="cov8" title="1">{
    m.mu.RLock()
    defer m.mu.RUnlock()

    keys := make([]string, 0, len(m.data))
    for key := range m.data </span><span class="cov8" title="1">{
        keys = append(keys, key)
    }</span>

    <span class="cov8" title="1">return keys, nil</span>
}

// Close closes the backend (no-op for memory backend)
func (m *MemoryBackend) Close() error <span class="cov8" title="1">{
    return nil
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
